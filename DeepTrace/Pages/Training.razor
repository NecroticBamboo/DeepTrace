@page "/training"
@using DeepTrace.Data;
@using DeepTrace.ML;
@using DeepTrace.Services;
@using System.ComponentModel.DataAnnotations;
@using DeepTrace.Controls;
@using Microsoft.ML;
@using PrometheusAPI;

@inject PrometheusClient Prometheus
@inject IDialogService DialogService
@inject IDataSourceStorageService StorageService
@inject IModelStorageService ModelService
@inject IEstimatorBuilder EstimatorBuilder
@inject NavigationManager NavManager
@inject IJSRuntime Js


<PageTitle>Training</PageTitle>

<style>
    .graph {
        max-width: 800px;
        max-height: 600px;
    }
</style>

<h1>Training</h1>

<MudGrid Justify="Justify.FlexStart">
    <MudItem xs="12" sm="6" md="6" lg="3">

        <MudCard Class="mb-3">
            <MudCardActions>
                <MudSelect T="ModelStorage" Label="Model name" AnchorOrigin="Origin.BottomCenter" @bind-Value="_modelForm!.CurrentModel">
                    @foreach (var model in _modelDefinitions)
                    {
                        <MudSelectItem Value="@model">@model.Name</MudSelectItem>
                    }
                </MudSelect>

                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleAddModel">Add</MudButton>
                @if (_modelDefinitions.Count > 1)
                {
                    <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleDeleteModel">Delete</MudButton>
                }
            </MudCardActions>
            <MudCardActions>
                <MudSelect T="DataSourceStorage" Label="Data source name" AnchorOrigin="Origin.BottomCenter" @bind-Value="_modelForm!.DataSource">
                    @foreach (var source in _dataSources)
                    {
                        <MudSelectItem Value="@source">@source.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudCardActions>
        </MudCard>

        <MudCard Class="mb-3">
            <MudTextField Label="Model name" T="String" Variant="Variant.Text" InputType="InputType.Search" @bind-Value="_modelForm!.CurrentModel.Name" />
            <MudTextField Label="AI parameters" T="String" Variant="Variant.Text" InputType="InputType.Search" />
        </MudCard>

        <MudCard Class="mb-3">
            <MudCardActions>
                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleAddTableContent" Disabled="@IsAddDisabled">Add</MudButton>
                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleRefresh" Disabled="@IsAddDisabled">Refresh</MudButton>
                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleExport" Disabled="@IsAddDisabled">Export</MudButton>
                <MudSpacer/>

                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="MudBlazor.Color.Primary" Class="ml-3" OnClick="@HandleTrain">Train</MudButton>
            </MudCardActions>

            <MudTable 
                Items="@_modelForm!.CurrentModel.IntervalDefinitionList" 
                Hover="true" 
                FixedHeader="@fixed_header"
                Height="400px"
                CanCancelEdit="@canCancelEdit" 
                RowEditPreview="@BackupInterval"
                RowEditCancel="ResetItemToOriginalValues"
                RowEditCommit="ItemHasBeenCommitted"
                Breakpoint="Breakpoint.Sm"
                T="IntervalDefinition"
            >
                <HeaderContent>
                    <MudTh>From</MudTh>
                    <MudTh>To</MudTh>
                    <MudTh>Name</MudTh>
                    <MudTh></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="From">@context.From</MudTd>
                    <MudTd DataLabel="To">@context.To</MudTd>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Class="ml-3" OnClick="@(()=>HandleDeleteTableContent(context))"></MudIconButton>
                </RowTemplate>
                <RowEditingTemplate>
                    <MudTd DataLabel="From">@context.From</MudTd>
                    <MudTd DataLabel="To">@context.To</MudTd>
                    <MudTd DataLabel="Name">
                        <MudTextField @bind-Value="@context.Name" Required />
                    </MudTd>
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Class="ml-3" OnClick="@(()=>HandleDeleteTableContent(context))"></MudIconButton>
                </RowEditingTemplate>
            </MudTable>
        </MudCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="6" lg="9">
        <MudCard>
            <MudCardContent>
                <div hidden="@IsChartShown"><MudProgressCircular Color="MudBlazor.Color.Default" /></div>
                <div hidden="@IsChartHidden">
                    @*Bind minDate and maxDate*@
                    <TimeSeriesChart Data="@DisplayData" @bind-MinDate=MinDate @bind-MaxDate=MaxDate />
                </div>
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

@code {

    private bool IsChartHidden => DisplayData == null;
    private bool IsChartShown => !IsChartHidden;
    private bool fixed_header = true;
    private bool canCancelEdit = true;
    private string _nameBackUp = "";

    private class ModelForm
    {
        public ModelForm(Training self)
        {
            _self = self;
        }

        private ModelStorage _currentModel = new();
        private readonly Training _self;

        [Required]
        public DataSourceStorage DataSource
        {
            get
            {
                return _currentModel.DataSource;
            }
            set
            {
                if(_currentModel.DataSource == value)
                {
                    return;
                }
                _currentModel.DataSource = value;
                _self.InvokeAsync(_self.HandleRefresh);
                _self.InvokeAsync(_self.HandleShowQuery);
            }
        }

        [Required]
        public ModelStorage CurrentModel 
        {
            get
            {
                return _currentModel;
            }
            set
            {
                if (_currentModel == value)
                {
                    return;
                }
                _currentModel = value;
                _self.InvokeAsync(_self.HandleShowQuery);
                _self.StateHasChanged();

            }
        }

        public DateRange Dates { get; set; } = new DateRange(DateTime.UtcNow.Date - TimeSpan.FromDays(14), DateTime.UtcNow.Date);

        public TimeSpan? TimeStart { get; set; }
        public TimeSpan? TimeEnd { get; set; }

        public TimeSpan Step { get; set; } = TimeSpan.FromSeconds(20);
        public double StepSec
        {
            get => Step.TotalSeconds;
            set => Step = TimeSpan.FromSeconds(value);
        }
    }

    private ModelForm? _modelForm;
    private TimeSeriesData? DisplayData { get; set; }
    private List<DataSourceStorage> _dataSources = new();
    private List<ModelStorage> _modelDefinitions = new() {new()};

    private DateTime? _minDate;
    private DateTime? _maxDate;
    private bool IsAddDisabled => DisplayData==null;

    private DateTime? MinDate
    {
        get
        {
            return _minDate ?? DisplayData?.Series.FirstOrDefault()?.Data.MinBy(x=>x.TimeStamp)?.TimeStamp;        
        }
        set
        {
            if (_minDate == value) return;
            _minDate = value;
            InvokeAsync(HandleShowQuery);
        }
    }

    private DateTime? MaxDate
    {
        get
        {
            return _maxDate ?? DisplayData?.Series.FirstOrDefault()?.Data.MaxBy(x => x.TimeStamp)?.TimeStamp;
        }
        set
        {
            if (_maxDate == value) return;
            _maxDate = value;
            InvokeAsync(HandleShowQuery);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        _modelForm = new(this);

        base.OnInitialized();

        var sources = await StorageService.Load();
        var models = await ModelService.Load();
        if (sources.Count > 0)
            _dataSources = sources;
        if (models.Count > 0)
            _modelDefinitions = models;

        _modelForm.CurrentModel = _modelDefinitions[0];
        var source = _dataSources.FirstOrDefault(x => x.Name == _modelDefinitions[0].DataSource.Name);
        _modelForm.DataSource = source ?? _dataSources[0];

    }

    private async Task HandleShowQuery()
    {
        if (_modelForm!.DataSource.Queries.Count < 1 || string.IsNullOrWhiteSpace(_modelForm.DataSource.Queries[0].Query) || _modelForm.Dates.End == null || _modelForm.Dates.Start == null)
            return;

        var startDate = MinDate ?? (DateTime.UtcNow - TimeSpan.FromDays(30));
        var endDate = MaxDate ?? DateTime.UtcNow;

        await UpdateDisplayData(startDate, endDate);

        await InvokeAsync(StateHasChanged);
    }

    private async Task UpdateDisplayData(DateTime startDate, DateTime endDate)
    {

        // use automatic step value to always request 500 elements
        var seconds = (endDate - startDate).TotalSeconds / 500.0;
        if (seconds < 1.0)
            seconds = 1.0;
        var step = TimeSpan.FromSeconds(seconds);

        var tasks = _modelForm!.DataSource.Queries
            .Select(x => Prometheus.RangeQuery(x.Query, startDate, endDate, step, TimeSpan.FromSeconds(2)))
            .ToArray();

        try
        {
            await Task.WhenAll(tasks);
        }
        catch (Exception e)
        {
            ShowError(e.Message);
            return;
        }

        var data = new List<TimeSeriesDataSet>();

        foreach (var (res, def) in tasks.Select((x, i) => (x.Result, _modelForm.DataSource.Queries[i])))
        {
            if (res.Status != StatusType.Success)
            {
                ShowError(res.Error ?? "Error");
                return;
            }

            if (res.ResultType != ResultTypeType.Matrix)
            {
                ShowError($"Got {res.ResultType}, but Matrix expected for {def.Query}");
                return;
            }

            var m = res.AsMatrix().Result;
            if (m == null || m.Length != 1)
            {
                ShowError($"No data returned for {def.Query}");
                return;
            }

            data.Add(
                new()
                    {
                        Name = def.Query,
                        Color = def.Color,
                        Data = m[0].Values!.ToList()
                    }
            );
        }

        DisplayData = new() { Series = data };
    }

    private void HandleAddModel()
    {
        _modelDefinitions.Add(new());
        _modelForm.CurrentModel = _modelDefinitions[^1];
        StateHasChanged();
    }

    private void HandleDeleteModel()
    {
        if (_modelDefinitions.Count < 2)
        {
            return;
        }

        var pos = _modelDefinitions.IndexOf(_modelForm!.CurrentModel);
        if (pos < 0)
        {
            ShowError("Not found");
            return;
        }

        var toDelete = _modelDefinitions[pos];
        _modelDefinitions.RemoveAt(pos);
        _modelForm.CurrentModel = _modelDefinitions[pos < _modelDefinitions.Count ? pos : _modelDefinitions.Count - 1];

        if (toDelete.Id != null)
        {
            ModelService.Delete(toDelete);
        }

        StateHasChanged();
    }

    private async Task HandleAddTableContent()
    {
        var interval = new IntervalDefinition
        {
            From = MinDate!.Value,
            To = MaxDate!.Value,
            Name = "Unknown",
            Data = DisplayData!.Series
        };
        _modelForm!.CurrentModel.IntervalDefinitionList.Add(interval);
        await ModelService.Store(_modelForm!.CurrentModel);
        await InvokeAsync(StateHasChanged);
    }

    private void BackupInterval(object element)
    {
        if(element is IntervalDefinition interval)
        {
            _nameBackUp = interval.Name;
        }

    }

    private void ResetItemToOriginalValues(object element)
    {
        if (element is IntervalDefinition interval)
        {
            interval.Name = _nameBackUp;
        }
    }

    private void ItemHasBeenCommitted(object element)
    {
        Task.Run(async ()=>ModelService.Store(_modelForm!.CurrentModel));
    }

    private async Task HandleRefresh()
    {
        var previousIntervals = _modelForm!.CurrentModel.IntervalDefinitionList;

        foreach(var currentInterval in previousIntervals)
        {
            await UpdateDisplayData(currentInterval.From,currentInterval.To);
            currentInterval.Data = DisplayData!.Series;
        }       
        await ModelService.Store(_modelForm!.CurrentModel);
        // await InvokeAsync(StateHasChanged);
    }

    private async Task HandleExport()
    {
        await Js.InvokeVoidAsync("open", $"{NavManager.BaseUri}api/download/mldata/{Uri.EscapeDataString(_modelForm.CurrentModel.Name)}", "_blank");

    }

    private async Task HandleDeleteTableContent(IntervalDefinition interval)
    {
        _modelForm!.CurrentModel.IntervalDefinitionList.Remove(interval);
        await ModelService.Store(_modelForm!.CurrentModel);
        await InvokeAsync(StateHasChanged);
    }

    private void ShowError(string text)
    {
        var options = new DialogOptions
            {
                CloseOnEscapeKey = true
            };
        var parameters = new DialogParameters();
        parameters.Add("Text", text);

        DialogService.Show<Controls.Dialog>("Error", parameters, options);
    }

    private void HandleTrain()
    {
        var mlContext = new MLContext();
        var pipeline = EstimatorBuilder.BuildPipeline(mlContext, _modelForm!.CurrentModel);

        
    }

    
}
